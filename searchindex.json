{"categories":[{"title":"技术杂文","uri":"https://neilliu9891.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E6%96%87/"},{"title":"技术杂谈","uri":"https://neilliu9891.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"},{"title":"效率工具","uri":"https://neilliu9891.github.io/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"},{"title":"随感","uri":"https://neilliu9891.github.io/categories/%E9%9A%8F%E6%84%9F/"}],"posts":[{"content":"Create Python Docker Image 记一次基于centos docker镜像创建python 3.7.9版本镜像的过程, 创建流程比较简单，目的记录使用了docker创建镜像的两种方式。\nQ: 为什么不使用官方的python镜像 A: 官方python镜像基于debian操作系统实现，而项目中多使用centos操作系统，为了保持一致，所以更新centos操作系统;构建的程序需要后台运行，基于systemctl 编写启动脚本实现，python官方镜像中并没有systemctl\n 文档记录并解决两个问题！\n 基于Centos7.8镜像如何安装生成python3.7.9的镜像文件 如何实现基于systemctl 服务的docker镜像的启动，以及如何编写k8s yaml文件实现systemctl  基础资源 官方docker仓库\n https://hub.docker.com/search?q=\u0026amp;type=image https://hub.docker.com/_/centos/?tab=description\n 生成python基础镜像 基于镜像commit方式生成新镜像  根据docker hub 搜索并下载合适的centos版本  docker pull centos:7.8.2003  通过run命令启动下载下来的image镜像并进入容器  docker run -it centos:7.8.2003 /bin/bash  执行安装python所必要的基础工具包(容器内执行)  yum install wget yum install yum-utils yum-builddep python3 # 下载python依赖 yum install make # 编包使用  安装python  wget https://www.python.org/ftp/python/3.7.9/Python-3.7.9.tgz #下载指定版本python包 tar xf Python-3.7.9.tgz # 解压包 cd Python-3.7.9 ./configure \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make install # 配置、编译、安装  退出并执行如下命令生成新镜像  docker ps -a | grep centos:7.8.2003 # 查看刚才启动的docker 容器 cfe4d2255644 centos:7.8.2003 \u0026quot;/usr/sbin/init\u0026quot; 18 hours ago Up 18 hours docker diff cfe4d2255644 # 显示差异，由于安装内容太多没必要显示 docker commit -m \u0026quot;centos python3.7.9\u0026quot; cfe4d2255644 imagename:tag # -m提交注释 ,imagename:tag表示新生成的容器名称  基于文件的方式生成新镜像 基于文件的方式生成镜像其实就是将之前的命令基于Dockerfile的形式执行一遍。\n 生成Dockerfile，内容如下：  FROM centos:7.8.2003 RUN yum install wget \u0026amp;\u0026amp; yum install yum-utils \u0026amp;\u0026amp; yum-builddep python3 \u0026amp;\u0026amp; yum install make RUN wget https://www.python.org/ftp/python/3.7.9/Python-3.7.9.tgz \u0026amp;\u0026amp; tar xf Python-3.7.9.tgz \u0026amp;\u0026amp; cd Python-3.7.9 \u0026amp;\u0026amp; ./configure \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make install CMD [/bin/bash]  执行生成镜像命令  docker -f Dockerfile . -t imagesname:tag  推送镜像到远端仓库  给镜像打远端仓库的tag  docker tag centos7.8-python3.7.9:latest 10.254.7.1:5000/imagesname:tag  执行push命令推送镜像  docker push 10.254.7.1:5000/imagesname:tag  如何在容器内运行systemctl命令以及后台运行服务 systemctl作为后台服务管理的工具，能够通过编写/etc/systemd/system/*.service的方式实现对服务的运行重启等功能。\nQ: python程序想要在不更换docker镜像的情况下，修改python代码并重新运行，只要docker不重启，服务就不会失效的功能，如何实现？ A: 通过编写service文件通过systemctl监控实现。\nQ: systemctl 在docker中运行失败，错误提示\nSystem has not been booted with systemd as init system (PID 1). Can't operate. Failed to connect to bus: Host is down  FailedtogetD-Busconnection: Operation not permitted   启动时添加\u0026ndash;privileged=true 使用/usr/sbin/init 使用-itd（即-d后台运行否则一直会卡在那里，没有命令行终端可用） example  docker run -itd --privileged=true images:tag /usr/sbin/init docker ps -a | grep image:tag # 获取容器的id docker run -it container_id /bin/bash # container_id:实际的容器id  ","id":0,"section":"posts","summary":"Create Python Docker Image 记一次基于centos docker镜像创建python 3.7.9版本镜像的过程, 创建流程比较简单，目的记录使用了docker创建镜像","tags":["docker"],"title":"Create Python Docker Image","uri":"https://neilliu9891.github.io/2020/10/create-python-docker-image/","year":"2020"},{"content":"Golang Private Lab 从gitlab私有仓库获取golang依赖包 例如golang go.mod文件中有如下配置信息\nmodule agent go 1.13 require ( ... moove/libvirt/libvirt-go v1.0.0 ) replace moove/libvirt/libvirt-go =\u0026gt; 10.0.45.221/moove/libvirt-go v1.0.5 # 替换成本地库  此时就需要配置10.0.45.221 这个gitlab仓库作为golang的私有仓库下载libvirt包\n配置通过ssh 访问gitlab  生成ssh公私钥对。  ssh-keygen -t rsa -C \u0026quot;example@example.com\u0026quot; -b 4096 #-t 表示秘钥类型 -C comment信息    秘钥名称可以默认，也可以自定义，如果自定义参考步骤5 passphrase 是指使用这个秘钥时需要的认证密码，一般我都不会再设置了，省的麻烦，毕竟是自己的电脑相对安全一些。如果非个人电脑建议配置简单秘钥。\n  复制~/.ssh/ 目录下生成的公钥信息到系统剪切板   登录gitLab账户，找到SSH选项，配置公钥信息  复制粘贴公钥到空白区域，填写title信息，title不重要，可以随便起   添加秘钥即可Add Key\n  如果生成的秘钥名称不是默认的秘钥名称，则需要进行如下操作，将秘钥信息纳管到ssh-agent服务中，并且需要在~/.ssh/config 文件中配置服务器地址信息,config文件没有创建\n 编写config文件如下  Host github.com │~ │~ HostName github.com │~ │~ PreferredAuthentications publickey │~ │~ IdentityFile ~/.ssh/11111  Host: 作为此配置的名称，可以随便命名。 HostName: 服务地址，如上就是github.com, 也可以直接配置ip地址 IdentityFile: 表示ssh生成的私钥文件路径\n 执行如下命令  eval $(ssh-agent -s) ssh-add ~/.ssh/other_id_rsa  other_id_rsa 替换成自己的私钥文件\n   如果通过如下命令能够正确返回登录的用户信息，则说明配置成功了\nssh -T git@github.com  此时，我们就能够通过git git@example/example.git 命令以ssh的方式下载代码了。\ngit 配置 git config --global url.\u0026quot;git@10.0.45.221:\u0026quot;.insteadof \u0026quot;http://10.0.45.221/\u0026quot;  此处的\u0026ndash;global配置也可以改成\u0026ndash;local，只有某个项目使用这个替换方式,即将http访问数据包的方式修改为通过ssh访问\ngolang 环境配置 go env -w GO111MODULE=on # 重点，启用go mod go env -w GOPRIVATE=\u0026quot;10.0.45.221\u0026quot; # 使用私有库， go get -u -v -insecure 10.0.45.221/moove/libvirt-go@latest # 获取libvirt-go的库 ![go env](/images/image_2020-10-12-20-36-49.png)``` 重点是配置开启MODULE模式，以及配置私有golang仓库的地址  ","id":1,"section":"posts","summary":"Golang Private Lab 从gitlab私有仓库获取golang依赖包 例如golang go.mod文件中有如下配置信息 module agent go 1.13 require ( ... moove/libvirt/libvirt-go v1.0.0 ) replace moove/libvirt/libvirt-go =\u0026gt; 10.0.45.221/moove/libvirt-go v1.0.5 # 替换成本地","tags":["golang","ssh","git"],"title":"Golang Private Lab","uri":"https://neilliu9891.github.io/2020/10/golang-private-lab/","year":"2020"},{"content":"种草很久的neovim工具使用 由于一直羡慕大神们用vim工具快速的编辑代码，并且羡慕能够不断优化适合自己的IDE工具。所以选择了neovim作为自己的IDE工具进行配置。 其实，自己是在vscode中使用的vim插件进行编辑，但是还是不能完全摆脱鼠标的操作，且一些功能在windows和macos上使用的不太一样，所以最终狠心学习一下neovim，以及开始尝试搭建自己的vim IDE工具。\n目标 适合自己的才是最好的，之前看了很多大神使用的各种插件，确实效率很高，让人羡慕不已，但是单单是把他们的插件配置拿过来是没有用的，倒不如自己从头搭建一个属于自己的IDE。 插件的查找方式从自己的需求出发，列出自己可能会用到的一些功能，在搜索需要的插件，个人认为这种方式可能更适合自己。\n插件管理工具 要想安装插件，必须有个趁手的管理工具，从网上搜索好多人建议使用vim-plug这个插件。\nvim-plug插件安装过程  vim-plug插件github地址及安装方法:https://github.com/junegunn/vim-plug,安装方式参考github上的Readme说明即可。 raw.githubusercontent.com 访问不了的问题解决  打开https://site.ip138.com/raw.Githubusercontent.com/，输入raw.githubusercontent.com，查询解析IP地址，选取一个IP地址，更改/etc/hosts，直接将raw.githubusercontent.com域名指向该IP地址。 重新执行github上的安装命令即可。    vim插件搜索网站  https://vimawesome.com/ 仅了解这一个网站，如果有更好的网站欢迎给我留言反馈  根据需求搜索需要的plug vim-plug插件管理  neovim配置文件所在位置./config/nvim/init.vim 向init.vim中写入自己的插件内容 for example  \u0026quot; Specify a directory for plugins \u0026quot; - For Neovim: stdpath('data') . '/plugged' \u0026quot; - Avoid using standard Vim directory names like 'plugin' call plug#begin('~/.vim/plugged') # 插件存放位置 \u0026quot; Plugin outside ~/.vim/plugged with post-update hook Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' } # 插件在github上的名称 \u0026quot; Initialize plugin system call plug#end()   执行命令:PlugInstall命令安装插件  IDE一样的目录树结构  The NERD tree Plug \u0026lsquo;scrooloose/nerdtree\u0026rsquo; Plug \u0026lsquo;preservim/nerdtree\u0026rsquo; 都是可以的，对应的github路径都是：https://github.com/preservim/nerdtree init.vim文件内容  call plug#begin('~/.vim/plugged') \u0026quot; https://vimawesome.com/plugin/nerdtree-red \u0026quot; github: https://github.com/preservim/nerdtree \u0026quot; Plug ‘scrooloose/nerdtree’ is the same Plug 'scrooloose/nerdtree' autocmd vimenter call plug#end()  切换工作台和目录 ctrl + w + h 光标 focus 左侧树形目录 ctrl + w + l 光标 focus 右侧文件显示窗口 ctrl + w + w 光标自动在左右侧窗口切换 ctrl + w + r 移动当前窗口的布局位置  基本操作命令 o 在已有窗口中打开文件、目录或书签，并跳到该窗口 go 在已有窗口 中打开文件、目录或书签，但不跳到该窗口 t 在新 Tab 中打开选中文件/书签，并跳到新 Tab T 在新 Tab 中打开选中文件/书签，但不跳到新 Tab i split 一个新窗口打开选中文件，并跳到该窗口 gi split 一个新窗口打开选中文件，但不跳到该窗口 s vsplit 一个新窗口打开选中文件，并跳到该窗口 gs vsplit 一个新 窗口打开选中文件，但不跳到该窗口 ! 执行当前文件 O 递归打开选中 结点下的所有目录 x 合拢选中结点的父目录 X 递归 合拢选中结点下的所有目录 e Edit the current dif D 删除当前书签 P 跳到根结点 p 跳到父结点 K 跳到当前目录下同级的第一个结点 J 跳到当前目录下同级的最后一个结点 k 跳到当前目录下同级的前一个结点 j 跳到当前目录下同级的后一个结点 C 将选中目录或选中文件的父目录设为根结点 u 将当前根结点的父目录设为根目录，并变成合拢原根结点 U 将当前根结点的父目录设为根目录，但保持展开原根结点 r 递归刷新选中目录 R 递归刷新根结点 m 显示文件系统菜单 cd 将 CWD 设为选中目录 I 切换是否显示隐藏文件 f 切换是否使用文件过滤器 F 切换是否显示文件 B 切换是否显示书签 q 关闭 NerdTree 窗口 ? 切换是否显示 Quick Help  切换标签页 :tabnew [++opt选项] ［＋cmd］ 文件 建立对指定文件新的tab :tabc 关闭当前的 tab :tabo 关闭所有其他的 tab :tabs 查看所有打开的 tab :tabp 前一个 tab :tabn 后一个 tab normal模式下： gT 前一个 tab gt 后一个 tab  自动代码补全 coc.vim\n配置 安装扩展插件，如下：\n:CocInstall coc-json coc-tsserver  配置go语言LSP，如下：\n:CocConfig { \u0026quot;languageserver\u0026quot;: { \u0026quot;go\u0026quot;: { \u0026quot;command\u0026quot;: \u0026quot;gopls\u0026quot;, \u0026quot;rootPatterns\u0026quot;: [\u0026quot;go.mod\u0026quot;], \u0026quot;trace.server\u0026quot;: \u0026quot;verbose\u0026quot;, \u0026quot;filetypes\u0026quot;: [\u0026quot;go\u0026quot;] } } }  python语言配置 :CocInstall coc-python  golang语言配置  方案一使用go-vim插件，添加如下配置到init.vim中  let g:go_def_mode='gopls' let g:go_info_mode='gopls'  方案二，使用coc.vim中配置lsp到coc-setting.json文件中  { \u0026quot;languageserver\u0026quot;: { \u0026quot;golang\u0026quot;: { \u0026quot;command\u0026quot;: \u0026quot;gopls\u0026quot;, \u0026quot;rootPatterns\u0026quot;: [\u0026quot;go.mod\u0026quot;, \u0026quot;.vim/\u0026quot;, \u0026quot;.git/\u0026quot;, \u0026quot;.hg/\u0026quot;], \u0026quot;filetypes\u0026quot;: [\u0026quot;go\u0026quot;], \u0026quot;initializationOptions\u0026quot;: { \u0026quot;usePlaceholders\u0026quot;: true } } } }   添加自动导入import 包，当文件中缺失要导入的包的时候,在init.vim中添加如下信息  autocmd BufWritePre *.go :call CocAction('runCommand', 'editor.action.organizeImport')  配置文件位置如下： 快速代码跳转 easymotion\n简单更改符号 vim-surround\ngolang开发环境 vim-go\nlet g:go_def_mode='gopls' let g:go_info_mode='gopls'   参考：https://github.com/fatih/vim-go/wiki\n ![入门指导]https://github.com/fatih/vim-go/wiki/Tutorial\n\u0026quot; autowrite, 执行:make时自动保存 set autowrite \u0026quot; shortcut for find error map \u0026lt;C-n\u0026gt; :cnext\u0026lt;CR\u0026gt; map \u0026lt;C-m\u0026gt; :cprevious\u0026lt;CR\u0026gt; nnoremap \u0026lt;leader\u0026gt;a :cclose\u0026lt;CR\u0026gt; \u0026quot; shortcut for go run, go build autocmd FileType go nmap \u0026lt;leader\u0026gt;b \u0026lt;Plug\u0026gt;(go-build) autocmd FileType go nmap \u0026lt;leader\u0026gt;r \u0026lt;Plug\u0026gt;(go-run)  map: 递归映射 : 表示回车 : 表示Ctrl+n noremap: 表示非递归调用 nmap\nlet g:go_list_type = \u0026quot;quickfix\u0026quot;  在当前文件的基础上增加一个对此文件的test文件，可以直接使用edit xxx_test.go的方式，会自动添加此包的package信息\n:edit main_test.go  Testing 执行go的Test测试\n:GoTest #执行go test命令 :GoTestFunc #执行光标所在Test函数的测试 # init.vim 中可以设置go test超时时间，由于go test并不是异步的，所以需要有超时时间，万一test挂了呢 let g:go_test_timeout = '10s'  进一步简化go build与go test,根据文件的结尾内容和.go的后缀来判断该执行go test or go build\n\u0026quot; run :GoBuild or :GoTestCompile based on the go file function! s:build_go_files() let l:file = expand('%') if l:file =~# '^\\f\\+_test\\.go$' call go#test#Test(0, 1) elseif l:file =~# '^\\f\\+\\.go$' call go#cmd#Build(0) endif endfunction autocmd FileType go nmap \u0026lt;leader\u0026gt;b :\u0026lt;C-u\u0026gt;call \u0026lt;SID\u0026gt;build_go_files()\u0026lt;CR\u0026gt;  格式化go文件, 当保存的时候会自动格式化\n:GoFmt # 关闭保存文件时自动格式化 let g:go_fmt_autosave = 0  导入包\n:GoImport strings # 导入strings包 :GoImport s # 通过tab键联想出要导入的包 :GoImportAs # 导入包的同时重定义名字 :GoDrop # 卸载包  自动导入缺失的包移除不需要的包，就是工具goimports\n:GoImports #多了一个s # 也可增加配置，在save的时候自动执行goimports let g:go_fmt_command = \u0026quot;goimports\u0026quot;  if 和 af 快捷方式 if: 当光标所在函数范围时，执行dif/vif/yif,分别表示删除、选中、复制函数内容，但不包括函数标题和函数注释 af: 与if相似但是会包括函数的标题和注释，将函数注释作为函数的doc信息 如果不想将函数的注释作为doc信息可以执行\nlet g:go_textobj_include_function_doc = 0  gS和gJ：分别用来将结构体表达式拆分成多行和合并成一行,需要安装如下插件\nPlug 'AndrewRadev/splitjoin.vim'  Snippets:快速添加代码片段,推荐安装插件 Ultisnips and neosnippet.此处我使用的是 Ultisnips\nPlug 'SirVer/ultisnips'  snippets 的tab键与YouComplete的tab键冲突\ngolang相关的snippets可以参见如下路径\n https://github.com/fatih/vim-go/blob/master/gosnippets/UltiSnips/go.snippets\n 举例：\nerrp: if err != nil { panic( ) ^ cursor position } type Foo struct { Name string # 此处输入json,则会自动添加`json:\u0026quot;name\u0026quot;` }  默认情况下json字符串的格式是下划线的形式，如果想要使用驼峰式，则可以进行如下修改：\nlet g:go_addtags_transform = \u0026quot;camelcase\u0026quot;  高亮type、function、caller等等\nlet g:go_highlight_types = 1 let g:go_highlight_fields = 1 let g:go_highlight_fields = 1 let g:go_highlight_function_calls = 1 let g:go_highlight_operators = 1 let g:go_highlight_extra_types = 1 let g:go_highlight_build_constraints = 1 let g:go_highlight_generate_tags = 1  tab转成4空格，默认VIM使用的是8个空格的tab\nautocmd BufNewFile,BufRead *.go setlocal noexpandtab tabstop=4 shiftwidth=4  设置配色,注意安装之后，需要将colors/molokai 拷贝到 .vim/目录下,否则找不到配色 colorscheme molokai这句话必须放在plug#begin（）plug#end()之外，否则提示找不到这个主题\nPlug 'fatih/molokai'  Navigate Alternate file 在foo.go 和foo_test.go 文件之间跳转，即在source file 和 test file之间跳转\n:GoAlternate  Go to definition 跳转到函数定义的位置\n:GoDef # shortcut ctrl+] 或者 gd  返回前一个浏览位置,只包括函数跳转\n:GoDefPop # shortcut ctrl+t  返回前一个浏览位置，包括移动的过程\nctrl+o # 如果执行了gd后又执行了滚屏等操作，或者move操作，则再执行ctrl+o是不会直接跳转到上一级函数的，而是一层层将之前的移动依次回退  前进到前一个位置即ctrl+o的反方向操作\nctrl+i  显示函数调用栈\n:GoDefStack  清除调用栈信息\n:GoDefStackClear  Move between functions 当我们不知道要查找的函数或者只知道函数名字的部分信息时，可以使用如下命令：\n:GoDecls # 显示当前文件中的函数 :GoDeclsDir #显示文件夹中的函数,但是不包括子文件夹  显示如下信息可以进行查找 安装插件ctrlp.vim,说是GoDecls必要插件，但是不装也可以,还是装上吧，毕竟装上之后显示的内容更多\nPlug 'ctrlpvim/ctrlp.vim'  快速的函数移动\n]] -\u0026gt; jump to next function [[ -\u0026gt; jump to previous function  设置快捷键GoAlternate\nautocmd Filetype go command! -bang A call go#alternate#Switch(\u0026lt;bang\u0026gt;0, 'edit') autocmd Filetype go command! -bang AV call go#alternate#Switch(\u0026lt;bang\u0026gt;0, 'vsplit') autocmd Filetype go command! -bang AS call go#alternate#Switch(\u0026lt;bang\u0026gt;0, 'split') autocmd Filetype go command! -bang AT call go#alternate#Switch(\u0026lt;bang\u0026gt;0, 'tabe')  Understand it Documentation lookup 获取函数的comment信息，可以通过如下命令：\n:GoDoc  GoDoc只是显示光标所在函数的comment信息，并不是文档管理器，如果想要使用文档管理器可以安装go-explorer插件\nIdentifier resolution 我们在编码时经常需要知道函数的参数和返回值等信息，可以使用如下命令显示\n:GoInfo # shortcut autocmd FileType go nmap \u0026lt;Leader\u0026gt;i \u0026lt;Plug\u0026gt;(go-info) # 自动显示info信息,当光标停留在合法的描述符上后，会自动显示info信息 let g:go_auto_type_info = 1 # 设置停留时间 set updatetime=100  Identifier highlighting 有时候我们需要高亮某个标识符，此时可以使用如下命令：\n:GoSameIds  清除高亮\n:GoSameIdsClear  自动高亮设置\n:GoSameIdsAutoToggle # 临时生效 #或者永久生效配置init.vim let g:go_auto_sameids = 1  Dependencies and files :GoFiles :GoDeps  Guru Guru是一个导航工具，一般由于查看代码使用。vim-go集成了一部分guru的功能。\n guru: https://golang.org/s/using-guru\n 显示光标所在标识符的所有引用，包括标识符的定义\n:GoReferrers  显示光标所在标识符的详细信息, 与GoInfo相似不过信息更多，如果是个结构体，包括结构体定义的方法等都会显示出来\n:GoDescribe  显示一个方法对应的实现了那个接口\n:GoImplements  显示err可能的值是哪些，如果是自定义的可能没办法获取，go自带的应该可以\n:GoWhicherr  显示channel分配，send、recv的信息\n:GoChannelPeer  显示调用者信息以及调用栈信息\n:GoCallees :GoCallers :GoCallstack  Refactor it Remane 替换光标所在标识符的名称\n:GoRename bar  当函数比较复杂的时候，可以通过GoFreeVars抽出部分代码生成一个函数，GoFreevars会根据你的选择判断哪些变量定义是需要作为入参的\n# 先选中一段代码,在执行如下 :GoFreevars # quickfix中显示的内容就是函数需要的入参定义  Generate it 通过快捷方式，实现快速定义某个接口的方法\n# 先定义一个struct, 光标移至此struct执行如下命令 :GoImpl  智能补全功能 通过安装coc.vim插件，并配置coc-setting.json文件\n{ \u0026quot;languageserver\u0026quot;: { \u0026quot;golang\u0026quot;: { \u0026quot;command\u0026quot;: \u0026quot;gopls\u0026quot;, \u0026quot;rootPatterns\u0026quot;: [\u0026quot;go.mod\u0026quot;], \u0026quot;disableWorkspaceFolders\u0026quot;: true, \u0026quot;filetypes\u0026quot;: [\u0026quot;go\u0026quot;] } } }  需要注意的是gopls必须是能够直接被调用的否则coc.vim插件执行gopls命令会失败\n显示函数和变量 tagbar\n模糊查找工具fzf fzf\nairline 提示文件类型，名称等信息插件 airline\nmarkdown插入剪切板图片 通过nvim编写markdown文章，但是导入图片却是个麻烦事儿，从网上找打vim插件，可以直接一键导入image\n\u0026quot;https://github.com/ferrine/md-img-paste.vim Plug 'ferrine/md-img-paste.vim' autocmd FileType markdown nmap \u0026lt;buffer\u0026gt;\u0026lt;silent\u0026gt; \u0026lt;leader\u0026gt;p :call mdip#MarkdownClipboardImage()\u0026lt;CR\u0026gt; \u0026quot; there are some defaults for image directory and image name, you can change them let g:mdip_imgdir = '.' let g:mdip_imgname = 'image' let g:mdip_imgdir_absolute = '/{xxx}/Blog/static/images' let g:mdip_imgdir_intext = '/images'   mdip_imgname:表示不输入图片时的默认名称 mdip_imgdir:表示输入名称的前缀 p:表示插入剪切板的内容到markdown文件中，并提示输入名称 mdip_imgdir_absolute: 表示图片保存的绝对路径，由于我的图片存储位置与markdown中输入的内容不同，所以使用相对位置等方式或者让mdip_imgdir即表示markdown中内容又表示文件保存位置是不可行的，所以使用绝对路径和markdown中前缀名称 mdip_imgdir_intext: 表示markdown文本中的前缀名称 规则：如果存在absolute，则使用absolute路径代替imgdir路径；如果没有intext路径，则markdown中使用imgdir表示的路径。   参考https://www.cnblogs.com/mazhuang/p/12863702.html\n ","id":2,"section":"posts","summary":"种草很久的neovim工具使用 由于一直羡慕大神们用vim工具快速的编辑代码，并且羡慕能够不断优化适合自己的IDE工具。所以选择了neovim","tags":["neovim","golang"],"title":"Golang IDE工具搭建（neovim篇）","uri":"https://neilliu9891.github.io/2020/10/20201005-nvim/","year":"2020"},{"content":"github 显示照片 在访问别人的github项目时，阅读Readme经常发现不能显示照片。后来查看发现是由于picture所存储的图床地址不能通过dns解析\n修改方法  查找picture对应的服务器地址  根据服务器地址，通过https://site.ip138.com/ 网址查询网页获取这个服务器地址所对应的ip地址  更新/etc/hosts 文件，将ip地址与服务器地址对应，写入/etc/hosts中。如果是windows系统则修改C:\\Windows\\System32\\drivers\\etc\\hosts地址   参考链接：\n https://blog.csdn.net/qq_38232598/article/details/91346392 https://blog.csdn.net/dplovel/article/details/107356603\n 查询网址：\n https://site.ip138.com/\n ","id":3,"section":"posts","summary":"github 显示照片 在访问别人的github项目时，阅读Readme经常发现不能显示照片。后来查看发现是由于picture所存储的图床地址不能通过dn","tags":["git"],"title":"Github ShowPicture","uri":"https://neilliu9891.github.io/2020/10/20201005-githubshowpicture/","year":"2020"},{"content":"It\u0026rsquo;s a draft 他只是个草稿！！！\n没想到我的第一篇博客诞生的如此坎坷，Hugo 是一个很便的博客搭建程序，怎奈自己的技术水平有限，导致 About 页面一直刷不出来。 究其原因，就是我的一个 draft：true 搞的鬼！\n 被标记为 draft：true 的文件不会被展示 如果 About 目录或者 Posts 目录下没有可以展示的内容，则会返回 404 错误  反思：\n 英语是个好东西，至少对于编程来说是的 弄懂原理一切都不会太难，关键是要有耐心研究它  ","id":4,"section":"posts","summary":"It\u0026rsquo;s a draft 他只是个草稿！！！ 没想到我的第一篇博客诞生的如此坎坷，Hugo 是一个很便的博客搭建程序，怎奈自己的技术水平有限，导致 About 页面一直刷不出来","tags":null,"title":"我的第一篇Blog:It's a draft","uri":"https://neilliu9891.github.io/2020/09/20200928-draft/","year":"2020"}],"tags":[{"title":"docker","uri":"https://neilliu9891.github.io/tags/docker/"},{"title":"git","uri":"https://neilliu9891.github.io/tags/git/"},{"title":"golang","uri":"https://neilliu9891.github.io/tags/golang/"},{"title":"neovim","uri":"https://neilliu9891.github.io/tags/neovim/"},{"title":"ssh","uri":"https://neilliu9891.github.io/tags/ssh/"}]}